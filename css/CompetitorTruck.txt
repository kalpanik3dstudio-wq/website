using UnityEngine;
using FCG;
using System.Collections.Generic;

public class CompetitorCrashDriver : MonoBehaviour
{
    [Header("Movement")]
    public float speed = 12f;
    public float turnSpeed = 6f;

    [Header("Targeting")]
    public float homingRange = 30f;
    public float hardLockRange = 10f;
    public float homingStrength = 0.5f;
    public float crashDistance = 3.5f;

    [HideInInspector] public DrivingGameManager manager;

    private Rigidbody rb;
    private Transform player;

    private FCGWaypointsContainer lane;
    private int node = 0;
    private int crashNode = 0;

    private bool crashed = false;

    void Start()
    {
        if (manager == null)
        {
            Debug.LogError("CompetitorCrashDriver: manager missing!");
            enabled = false; return;
        }

        if (manager.playerCar == null)
        {
            Debug.LogError("CompetitorCrashDriver: player missing!");
            enabled = false; return;
        }

        player = manager.playerCar.transform;

        rb = GetComponent<Rigidbody>();
        if (rb == null)
        {
            Debug.LogError("CompetitorCrashDriver: Rigidbody missing!");
            enabled = false; return;
        }

        // AUTO LANE SYSTEM
        AutoSelectLane();

        // AUTO-WAYPOINT SETUP
        AutoSelectClosestNode();

        Debug.Log($"Auto-lane selected: {lane.name}, start node: {node}, crash node: {crashNode}");
    }

    // -------------------------------------------------------
    // AUTO-SELECT NEAREST LANE
    // -------------------------------------------------------
    void AutoSelectLane()
    {
        FCGWaypointsContainer[] allLanes = FindObjectsOfType<FCGWaypointsContainer>();

        if (allLanes.Length == 0)
        {
            Debug.LogError("No FCGWaypointsContainer lanes found in scene!");
            enabled = false;
            return;
        }

        float bestDist = float.MaxValue;

        foreach (var ln in allLanes)
        {
            if (ln.waypoints.Count == 0) continue;

            float dist = Vector3.Distance(transform.position, ln.waypoints[0].position);
            if (dist < bestDist)
            {
                bestDist = dist;
                lane = ln;
            }
        }
    }

    // -------------------------------------------------------
    // AUTO-SELECT NEAREST WAYPOINT
    // -------------------------------------------------------
    void AutoSelectClosestNode()
    {
        int bestNode = 0;
        float bestDist = float.MaxValue;

        for (int i = 0; i < lane.waypoints.Count; i++)
        {
            float d = Vector3.Distance(transform.position, lane.waypoints[i].position);
            if (d < bestDist)
            {
                bestDist = d;
                bestNode = i;
            }
        }

        node = bestNode;
        crashNode = Mathf.Max(0, node - 4); // begin homing ~4 nodes before player

        // Snap truck to lane
        transform.position = lane.waypoints[node].position + Vector3.up * 0.35f;

        LookAtNext();
    }

    void LookAtNext()
    {
        Vector3 dir = lane.waypoints[node].position - transform.position;
        dir.y = 0;

        if (dir.sqrMagnitude > 0.1f)
            transform.rotation = Quaternion.LookRotation(dir);
    }

    // -------------------------------------------------------
    // MAIN MOVEMENT LOOP
    // -------------------------------------------------------
    void FixedUpdate()
    {
        if (crashed || player == null) return;

        Vector3 laneDir = lane.waypoints[node].position - transform.position;
        laneDir.y = 0;

        float laneSq = laneDir.sqrMagnitude;

        if (laneSq < 0.05f || node == crashNode)
        {
            laneDir = (player.position - transform.position).normalized;
            laneDir.y = 0;
        }
        else laneDir.Normalize();

        float distToPlayer = Vector3.Distance(transform.position, player.position);
        Vector3 toPlayer = (player.position - transform.position).normalized;
        toPlayer.y = 0;

        Vector3 finalDir = laneDir;

        if (distToPlayer < homingRange)
            finalDir = Vector3.Lerp(laneDir, toPlayer, homingStrength);

        if (distToPlayer < hardLockRange)
            finalDir = toPlayer;

        rb.MovePosition(transform.position + finalDir * speed * Time.deltaTime);

        Quaternion targetRot = Quaternion.LookRotation(finalDir, Vector3.up);
        transform.rotation = Quaternion.Slerp(transform.rotation, targetRot, Time.deltaTime * turnSpeed);

        float nodeDist = Vector3.Distance(transform.position, lane.waypoints[node].position);
        if (nodeDist < 2f && node > crashNode)
            node--;

        if (distToPlayer < crashDistance)
            CrashNow();
    }

    void CrashNow()
    {
        if (crashed) return;
        crashed = true;

        rb.velocity = Vector3.zero;
        rb.angularVelocity = Vector3.zero;

        rb.AddForce(transform.forward * 50f, ForceMode.Impulse);

        Debug.Log("ðŸ’¥ Competitor CRASHED!");
        manager.OnCrashImpact(transform);
    }
}
